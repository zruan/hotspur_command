#!/eppec/storage/sw/cky-tools/site/bin/python
from sqlitedict import SqliteDict
import pystar2
import numpy as np
# import modules used here -- sys is a very standard one
import sys, argparse, logging, os
import json

def load(path):
    return list(pystar2.load(path)[''].values())[0]

def save(particles, orig, path):
    keys = orig.dtype.names
    pystar2.save( { '': {keys: particles } }, path)

def save_star(keypoints, path):
    with open(path, 'w') as dst:
        dst.write('''
data_

loop_
_rlnCoordinateX #1
_rlnCoordinateY #2
_rlnAnglePsi #3
_rlnClassNumber #4
_rlnAutopickFigureOfMerit #5
''')
        for keypoint in keypoints:
            psi = 0.0
            cls = 1
            dst.write('%.6f %.6f %.6f %d %.6f\n' % (keypoint[0][1], keypoint[0][0], psi, cls, keypoint[1]))

def check_directory(args):
    if not os.path.isfile("data.json"):
        logging.error("This does not seem like /hotspur/scratch project folder")
        sys.exit()
    with open("data.json","r") as fp:
        data = json.load(fp)
    if args.set =="all" and args.type == "micrographs":
        return((data,{}))
    if not os.path.isfile("annotation.db"): 
        logging.error("No annotations were found, I can only export all micrographs")
        sys.exit()
    mydict = SqliteDict("annotation.db")
    return((data,mydict))

def export_micrographs(data,annotation,micrograph_set,name):
    logging.debug(list(data.values())[0]["Gctf"])
    list_micrographs = [ (k,v["Gctf"]["ctf_star_filename"]) for k,v in data.items() if "Gctf" in v ]
    list_export = []
    logging.debug(list_micrographs)
    star_data = 0
    star_data_list=[]
    if micrograph_set == "all":
        list_export = list_micrographs
    elif micrograph_set == "good":
        for (key, v) in list_micrographs:
            if "tag" in mydict[key] and mydict[key]["tag"] == "good":
                list_export.append((key, v))
    elif micrograph_set == "notbad":
        for (key, v) in list_micrographs:
            if "tag" not in mydict[key] or mydict[key]["tag"] != "bad":
                list_export.append((key, v))


    for (key, starfile) in list_export:
        if star_data == 0:
            star_data = load(starfile)
            star_data_list.append(star_data[0])
        else:
            star_data_list.append(load(starfile)[0])

    filename = "microgaphs_"+name+".star"
    logging.info("Exporting %i microgaphs as %s" % (len(list_export), filename))
    save(star_data_list, star_data, filename)
# Gather our code in a main() function
def main(args, loglevel):
    logging.basicConfig(format="%(levelname)s: %(message)s", level=loglevel)
  
  # TODO Replace this with your actual code.
    (data, annotation) = check_directory(args)
    export_micrographs(data,annotation,args.set,args.name)

 
# Standard boilerplate to call the main() function to begin
# the program.
if __name__ == '__main__':
    parser = argparse.ArgumentParser( 
                                        description = "This tool exports micrographs or particles from hotspur. Use in /hotspur/scratch/<user>/<dataset>"
                                         )
      # TODO Specify your real parameters here.
    parser.add_argument(
                          "--set",
                          help = "Which set of micrographs to export. Default = notbad",
                          choices = ["all","good","notbad"],
                          default = "notbad"
                          )
    parser.add_argument(
                          "--type",
                          help = "What to export: Micrographs or particles. Default = micrographs",
                          choices = ["micrographs","particles"],
                          default = "micrographs"
                          )
    parser.add_argument(
                          "--name",
                          help = "Name for the exported data",
                          required=True
                          )
    parser.add_argument(
                          "-v",
                          "--verbose",
                          help="increase output verbosity",
                          action="store_true")
    args = parser.parse_args()
      
      # Setup logging
    if args.verbose:
        loglevel = logging.DEBUG
    else:
        loglevel = logging.INFO
      
    main(args, loglevel)


#!/usr/bin/python

import argparse
import imaging
import pystar
import pyfs
import numpy as np
import wx

import matplotlib
matplotlib.use('WXAgg')
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
from matplotlib.backends.backend_wxagg import \
        FigureCanvasWxAgg as FigCanvas, \
        NavigationToolbar2WxAgg as NavigationToolbar
import pylab

def arguments():

    def floatlist(string):
        return list(map(float, string.split(',')))

    parser = argparse.ArgumentParser(
        description='runs dog picker on up to 4 mrc files interactively to optimixe parameters')
    
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--mrc', nargs='+', help='path to MRC input image')
    parser.add_argument('-i', '--invert', default=False, action='store_true',
                        help='invert image so that particles are black on a white background')
    return parser.parse_args()


def dog_size(s1, s2):
    k = s2 / s1
    k2 = k**2
    k21 = k2 - 1
    return s1 / np.sqrt(k21 / (2 * k2 * np.log(k)))


def dog_ends(size, k):
    radius = float(size) / 2.0
    sigma = radius / np.sqrt( (2*k*k*np.log(k)) / (k*k-1) )
    return sigma, sigma * k


def sig_diff(s1, s2):
    return np.sqrt(s2*s2 - s1*s1)


def dog(image, size, k):
    s1, s2 = dog_ends(size, k)
    g1 = imaging.filters.gaussian(image, s1)
    g2 = imaging.filters.gaussian(image, s2)
    return ( g1 - g2 ) * ( float(size) / 2.0 ) * ( k - 1.0 )


def log(image, size):
    # this is the sigma that gives zero-crossings at given radius
    sigma = ( size / 2.0 ) / np.sqrt(2)
    # return scale-normalized result by multiplying with sigma^2
    return -imaging.filters.laplace(image, sigma)*sigma*sigma


def detect(image, size, mint=None, maxt=None, debug=None, meanmax=None):
    zoom = min(1.0, 15.0 / size)
    reduced_image = imaging.filters.zoom(image, zoom)
    rzoom = float(reduced_image.shape[0]) / float(image.shape[0])
    czoom = float(reduced_image.shape[1]) / float(image.shape[1])
    reduced_size = np.mean([rzoom, czoom]) * size
    log_image = -log(reduced_image, reduced_size)
    peaks = list(imaging.detection.peaks.maxima(log_image, 3))
    if len(peaks):
        pvalues = np.sort(np.array([v for _, v in peaks]))
        if maxt is None:
            maxt = pvalues[-1]
        if mint is None:
            mint = max(0, pvalues[0])
        peaks = [(p, v) for p, v in peaks if v <= maxt]
        peaks = [(p, v) for p, v in peaks if v >= mint]
        if meanmax is not None:
            stdvs = [peak_mean(peak, reduced_size/2, reduced_image) for peak in peaks]
            peaks = [peak for peak, stdv in zip(peaks, stdvs) if stdv < meanmax]
            if debug:
                print('current peak stdv distribution:')
                counts, bins = np.histogram(stdvs, bins=10)
                for idx in range(len(counts)):
                    print('  % 13.2f -> % 13.2f: %d' % (bins[idx], bins[idx+1], counts[idx]))
        if debug: 
            print('current peak range: %f -> %f' % (mint, maxt))
            print('distribution within range:')
            print('  low threshold -> max threshold: peak count')
            counts, bins = np.histogram(pvalues, bins=10, range=(mint, maxt))
            for idx in range(len(counts)):
                print('  % 13.2f -> % 13.2f: %d' % (bins[idx], bins[idx+1], counts[idx]))
            save_peaks(reduced_image, log_image, peaks, reduced_size, debug)
        return zoom_peaks(peaks, [rzoom, czoom])
    return []


def peak_mean(peak, radius, image):
    lr = int(max(0,  peak[0][0] - radius))
    rr = int(min(image.shape[0], peak[0][0] + radius))
    lc = int(max(0,  peak[0][1] - radius))
    rc = int(min(image.shape[1], peak[0][1] + radius))
    stdv = np.std(image[lr:rr, lc:rc])
    return stdv


def inrange(v, mint=None, maxt=None):
    if mint is None:
        mint = v
    if maxt is None:
        maxt = v
    return mint <= v <= maxt


def colorize_log_map(logimage, mint, maxt):
    colorized = imaging.filters.norm(logimage, 0.01, 0.01, -1.0, 1.0)
    colorized = imaging.filters.asRGB(logimage)
    lt = 1.0 - imaging.filters.scale(np.fmax(mint-logimage, -0.1), 0.0, 1.0)
    gt = 1.0 - imaging.filters.scale(np.fmax(logimage-maxt, -0.1), 0.0, 1.0)
    colorized[:, :, 0] *= gt
    colorized[:, :, 1] *= gt * lt
    colorized[:, :, 2] *= lt
    return colorized


def save_peaks(image, log_image, peaks, size, path):
    image = imaging.filters.norm(image, 0.01, 0.01, 0, 255)
    keys = log_peaks_as_keypoints(peaks, size)
    image = imaging.detection.keypoints.draw(image, keys)
    picks_path = path + '.picks.png'
    peaks_path = path + '.peaks.png'
    print(' saving peaks png:', peaks_path)
    print(' saving picks png:', picks_path)
    imaging.save(image, picks_path)
    imaging.save(log_image, peaks_path)


def zoom_peaks(peaks, zoom):
    return [(tuple(np.array(p)*(1.0/np.array(zoom))), v) for p, v in peaks]


def log_peaks_as_keypoints(peaks, size):
    Keypoint = imaging.detection.keypoints.Keypoint
    return [Keypoint(p[0][0], p[0][1], size, 0.0, p[1], 1, 1) for p in peaks]


def save_star(keypoints, path):
    with open(path, 'w') as dst:
        dst.write('''
data_

loop_
_rlnCoordinateX #1
_rlnCoordinateY #2
_rlnAnglePsi #3
_rlnClassNumber #4
_rlnAutopickFigureOfMerit #5
''')
        for keypoint in keypoints:
            psi = 0.0
            cls = 1
            dst.write('%.6f %.6f %.6f %d %.6f\n' % (keypoint[0][1], keypoint[0][0], psi, cls, keypoint[1]))


def load_micrographs_star(path):
    values = pystar.load(path)[0]['data_']
    fields = list(values)[0]
    index = fields.index('rlnMicrographName')
    return [x[index] for x in list(values.values())[0]]


def get_micrographs(args):
    if args.mrc:
        return args.mrc
    elif args.glob:
        import glob
        return glob.glob(args.glob)
    elif args.star:
        return load_micrographs_star(args.star)
    raise ValueError()


def argidx(arg, idx, default):
    try:
        return arg[idx]
    except IndexError:
        return default

def circles(axes, x, y, s, c='b', vmin=None, vmax=None, **kwargs):
    """
    Make a scatter of circles plot of x vs y, where x and y are sequence 
    like objects of the same lengths. The size of circles are in data scale.

    Parameters
    ----------
    x,y : scalar or array_like, shape (n, )
        Input data
    s : scalar or array_like, shape (n, ) 
        Radius of circle in data unit.
    c : color or sequence of color, optional, default : 'b'
        `c` can be a single color format string, or a sequence of color
        specifications of length `N`, or a sequence of `N` numbers to be
        mapped to colors using the `cmap` and `norm` specified via kwargs.
        Note that `c` should not be a single numeric RGB or RGBA sequence 
        because that is indistinguishable from an array of values
        to be colormapped. (If you insist, use `color` instead.)  
        `c` can be a 2-D array in which the rows are RGB or RGBA, however. 
    vmin, vmax : scalar, optional, default: None
        `vmin` and `vmax` are used in conjunction with `norm` to normalize
        luminance data.  If either are `None`, the min and max of the
        color array is used.
    kwargs : `~matplotlib.collections.Collection` properties
        Eg. alpha, edgecolor(ec), facecolor(fc), linewidth(lw), linestyle(ls), 
        norm, cmap, transform, etc.

    Returns
    -------
    paths : `~matplotlib.collections.PathCollection`

    Examples
    --------
    a = np.arange(11)
    circles(a, a, a*0.2, c=a, alpha=0.5, edgecolor='none')
    plt.colorbar()

    License
    --------
    This code is under [The BSD 3-Clause License]
    (http://opensource.org/licenses/BSD-3-Clause)
    """
    from matplotlib.patches import Circle
    from matplotlib.collections import PatchCollection

    if np.isscalar(c):
        kwargs.setdefault('color', c)
        c = None
    if 'fc' in kwargs: kwargs.setdefault('facecolor', kwargs.pop('fc'))
    if 'ec' in kwargs: kwargs.setdefault('edgecolor', kwargs.pop('ec'))
    if 'ls' in kwargs: kwargs.setdefault('linestyle', kwargs.pop('ls'))
    if 'lw' in kwargs: kwargs.setdefault('linewidth', kwargs.pop('lw'))

    patches = [Circle((x_, y_), s_) for x_, y_, s_ in np.broadcast(x, y, s)]
    collection = PatchCollection(patches, **kwargs)
    if c is not None:
        collection.set_array(np.asarray(c))
        collection.set_clim(vmin, vmax)

    ax = axes
    ax.add_collection(collection)
    ax.autoscale_view()
    if c is not None:
        plt.sci(collection)
    return collection


class OneRangeBox(wx.Panel):
    """ A static box with a couple of radio buttons and a text
        box. Allows to switch between an automatic mode and a 
        manual mode with an associated value.
    """
    def __init__(self, parent, ID, label, initval):
        wx.Panel.__init__(self, parent, ID)
        
        self.value = initval
        
        box = wx.StaticBox(self, -1, label)
        sizer = wx.StaticBoxSizer(box, wx.VERTICAL)
        
        self.low_label = wx.StaticText(self, -1, 
            label="Value", style=wx.RB_GROUP)
        self.low_text = wx.TextCtrl(self, -1, 
            size=(35,-1),
            value=str(initval),
            style=wx.TE_PROCESS_ENTER)
        
        self.Bind(wx.EVT_TEXT_ENTER, self.on_text_enter, self.low_text)
        
        manual_box_low = wx.BoxSizer(wx.HORIZONTAL)
        manual_box_low.Add(self.low_label, flag=wx.ALIGN_CENTER_VERTICAL)
        manual_box_low.Add(self.low_text, flag=wx.ALIGN_CENTER_VERTICAL)
        
        sizer.Add(manual_box_low, 0, wx.ALL, 10)
        
        self.SetSizer(sizer)
        sizer.Fit(self)
    
    def on_text_enter(self, event):
	try:
            low = float(self.low_text.GetValue())
	except ValueError:
            low = 0
            self.low_text.SetValue(u"0")
        self.value = low
    
        
    def get_value(self):
        return self.value


class TwoRangeBox(wx.Panel):
    """ A static box with a couple of radio buttons and a text
        box. Allows to switch between an automatic mode and a 
        manual mode with an associated value.
    """
    def __init__(self, parent, ID, label, initvals):
        wx.Panel.__init__(self, parent, ID)
        
        self.value = initvals
        
        box = wx.StaticBox(self, -1, label)
        sizer = wx.StaticBoxSizer(box, wx.VERTICAL)
        
        self.low_label = wx.StaticText(self, -1, 
            label="Low", style=wx.RB_GROUP)
        self.high_label = wx.StaticText(self, -1,
            label="High")
        self.low_text = wx.TextCtrl(self, -1, 
            size=(35,-1),
            value=str(initvals[0]),
            style=wx.TE_PROCESS_ENTER)
        self.high_text = wx.TextCtrl(self, -1, 
            size=(35,-1),
            value=str(initvals[1]),
            style=wx.TE_PROCESS_ENTER)
        
        self.Bind(wx.EVT_TEXT_ENTER, self.on_text_enter, self.high_text)
        self.Bind(wx.EVT_TEXT_ENTER, self.on_text_enter, self.low_text)
        
        manual_box = wx.BoxSizer(wx.HORIZONTAL)
        manual_box.Add(self.high_label, flag=wx.ALIGN_CENTER_VERTICAL)
        manual_box.Add(self.high_text, flag=wx.ALIGN_CENTER_VERTICAL)
        manual_box_low = wx.BoxSizer(wx.HORIZONTAL)
        manual_box_low.Add(self.low_label, flag=wx.ALIGN_CENTER_VERTICAL)
        manual_box_low.Add(self.low_text, flag=wx.ALIGN_CENTER_VERTICAL)
        
        sizer.Add(manual_box_low, 0, wx.ALL, 10)
        sizer.Add(manual_box, 0, wx.ALL, 10)
        
        self.SetSizer(sizer)
        sizer.Fit(self)
    
    def on_text_enter(self, event):
	try:
            low = float(self.low_text.GetValue())
	except ValueError:
            low = 0
            self.low_text.SetValue(u"0")
	try:
            high = float(self.high_text.GetValue())
	except ValueError:
            high = 0
            self.high_text.SetValue(u"0")
        self.value = (low,high)
    
        
    def get_value(self):
        return self.value


class GraphFrame(wx.Frame):
    """ The main frame of the application
    """
    title = 'Demo: dynamic matplotlib graph'
    
    def __init__(self,micrographs):
        wx.Frame.__init__(self, None, -1, self.title)
        
        self.micrographs = micrographs
        
        self.create_menu()
        self.create_status_bar()
        self.create_main_panel()
        
        self.redraw_timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self.on_redraw_timer, self.redraw_timer)        
        self.redraw_timer.Start(2000)

    def create_menu(self):
        self.menubar = wx.MenuBar()
        
        menu_file = wx.Menu()
        m_expt = menu_file.Append(-1, "&Save plot\tCtrl-S", "Save plot to file")
        self.Bind(wx.EVT_MENU, self.on_save_plot, m_expt)
        menu_file.AppendSeparator()
        m_exit = menu_file.Append(-1, "E&xit\tCtrl-X", "Exit")
        self.Bind(wx.EVT_MENU, self.on_exit, m_exit)
                
        self.menubar.Append(menu_file, "&File")
        self.SetMenuBar(self.menubar)

    def create_main_panel(self):
        self.panel = wx.Panel(self)

        self.init_plot()
        self.canvas = FigCanvas(self.panel, -1, self.fig)

        self.range_control = OneRangeBox(self.panel, -1, "Size     ", args.range)
        self.threshold_control = TwoRangeBox(self.panel, -1, "Threshold range", args.thresholds)
        self.meanmax_control = OneRangeBox(self.panel, -1, "Mean Max", args.meanmax)
        
        self.pause_button = wx.Button(self.panel, -1, "Detect")
        self.Bind(wx.EVT_BUTTON, self.on_pause_button, self.pause_button)
        
        self.cb_grid = wx.CheckBox(self.panel, -1, 
            "",
            style=wx.ALIGN_RIGHT)
        self.Bind(wx.EVT_CHECKBOX, self.on_cb_grid, self.cb_grid)
        self.cb_grid.SetValue(True)
        
        self.cb_xlab = wx.CheckBox(self.panel, -1, 
            "",
            style=wx.ALIGN_RIGHT)
        self.Bind(wx.EVT_CHECKBOX, self.on_cb_xlab, self.cb_xlab)        
        self.cb_xlab.SetValue(True)
        
        self.hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        self.hbox1.Add(self.pause_button, border=5, flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL)
        self.hbox1.AddSpacer(20)
        self.hbox1.Add(self.cb_grid, border=5, flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL)
        self.hbox1.AddSpacer(10)
        self.hbox1.Add(self.cb_xlab, border=5, flag=wx.ALL | wx.ALIGN_CENTER_VERTICAL)
        
        self.hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        self.hbox2.Add(self.range_control, border=5, flag=wx.ALL)
        self.hbox2.AddSpacer(24)
        self.hbox2.Add(self.threshold_control, border=5, flag=wx.ALL)
        self.hbox2.AddSpacer(24)
        self.hbox2.Add(self.meanmax_control, border=5, flag=wx.ALL)
        
        self.vbox = wx.BoxSizer(wx.VERTICAL)
        self.vbox.Add(self.canvas, 1, flag=wx.LEFT | wx.TOP | wx.GROW)        
        self.vbox.Add(self.hbox1, 0, flag=wx.ALIGN_LEFT | wx.TOP)
        self.vbox.Add(self.hbox2, 0, flag=wx.ALIGN_LEFT | wx.TOP)
        
        self.panel.SetSizer(self.vbox)
        self.vbox.Fit(self)
    
    def create_status_bar(self):
        self.statusbar = self.CreateStatusBar()

    def init_plot(self):
        self.dpi = 100
        self.fig = Figure((3.0, 3.0), dpi=self.dpi)

        self.axes = self.fig.add_subplot(111)
        self.axes.set_axis_bgcolor('black')
        #self.axes.set_title('Very important random data', size=12)
        
        pylab.setp(self.axes.get_xticklabels(), fontsize=8)
        pylab.setp(self.axes.get_yticklabels(), fontsize=8)

        # plot the data as a line series, and save the reference 
        # to the plotted line series
        #
        self.plot_data = self.axes.imshow(self.micrographs,cmap="Greys_r")
        self.plot_circles = self.axes.scatter([],[],marker='o',s=(1600^2)*np.pi,facecolors='none', edgecolors='r')

    

    def draw_plot(self):
        """ Redraws the plot
        """
        dx = 200/2
        self.plot_circles.remove()
        self.plot_circles = circles(self.axes,self.circle_x,self.circle_y,s=dx,edgecolor='r',facecolor='none')
        self.canvas.draw()
    
    def on_pause_button(self, event):
	args.range = self.range_control.get_value()
	args.thresholds = self.threshold_control.get_value()
	args.meanmax = self.meanmax_control.get_value()
	result = process(mics[0])
	print(result)
	app.frame.circle_x = [a[0][1] for a in result]
	app.frame.circle_y = [a[0][0] for a in result]
	self.draw_plot()
    
    
    def on_cb_grid(self, event):
        self.draw_plot()
    
    def on_cb_xlab(self, event):
        self.draw_plot()
    
    def on_save_plot(self, event):
        file_choices = "PNG (*.png)|*.png"
        
        dlg = wx.FileDialog(
            self, 
            message="Save plot as...",
            defaultDir=os.getcwd(),
            defaultFile="plot.png",
            wildcard=file_choices,
            style=wx.SAVE)
        
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            self.canvas.print_figure(path, dpi=self.dpi)
            self.flash_status_message("Saved to %s" % path)
    
    def on_redraw_timer(self, event):
        # if paused do not add data, but still redraw the plot
        # (to respond to scale modifications, grid change, etc.)
        #
        #if not self.paused:
        #    self.data.append(self.datagen.next())
        
        self.draw_plot()
    
    def on_exit(self, event):
        self.Destroy()
    
    def flash_status_message(self, msg, flash_len_ms=1500):
        self.statusbar.SetStatusText(msg)
        self.timeroff = wx.Timer(self)
        self.Bind(
            wx.EVT_TIMER, 
            self.on_flash_status_off, 
            self.timeroff)
        self.timeroff.Start(flash_len_ms, oneShot=True)
    
    def on_flash_status_off(self, event):
        self.statusbar.SetStatusText('')


def process(mic):
    try:
	image = imaging.load(mic)[0]    
    except KeyboardInterrupt:
	exit(-1)
    except Exception as e:
	print('[error] failed to process image: %s, %s' % (mic, e))
	return
    if args.invert:
	image = imaging.filters.invert(image)
    size = args.range
    meanmax = args.meanmax
    mint = argidx(args.thresholds, 0, None)
    maxt = argidx(args.thresholds, 1, None)
    debug = None
    keys = list(detect(image, size, mint, maxt, debug, meanmax))
    if len(keys) > 5:
	print('found %d particles in image %s -> %s' % (len(keys), mic, ""))
    return keys






if __name__ == '__main__':

    args = arguments()
    print(args)
    mics = get_micrographs(args)


    try:
        image = imaging.load(mics[0])[0]    
    except KeyboardInterrupt:
        exit(-1)
    except Exception as e:
        print('[error] failed to process image: %s, %s' % (mics[0], e))
        exit(-1)
    if args.invert:
        image = imaging.filters.invert(image)
    args.thresholds = (0.0,10)
    args.range = 200
    args.debug = False
    args.label = 'dog'
    args.meanmax = None
    result = process(mics[0])
    print(result)
    reduced_image = image
    norm_image = imaging.filters.norm(reduced_image, 0.01, 0.01, 0, 255)
    app = wx.App(False)
    app.frame = GraphFrame(norm_image)
    app.frame.circle_x = [a[0][1] for a in result]
    app.frame.circle_y = [a[0][0] for a in result]


    app.frame.Show()
    app.MainLoop()


